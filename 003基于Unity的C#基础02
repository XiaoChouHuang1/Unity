1.	1.文件(脚本)创建成功,不能修改  
2.	2,如果想让代码执行,必须把脚本挂在某一个物体上(让脚本称为某一个物体的组件  
3.	脚本的生命周期:一个脚本挂在某个物体之后所要经历的方法(自动调用)  
4.	1.reset:编辑阶段   
5.	2,Awake():脚本加载时执行此方法,执行一次,常用来对字段进行初始化  (注意大写)小写使用对象点调用(一次)  
6.	3,OnEnable();脚本如果可用,脚本是否可用,可用则执行此方法  ,如果设置为false那么后边的脚本不可用(两次)  
7.	4,Start () 开始阶段,在update之前执行一次此方法,常用来 获取游戏对象或者组件  (一次)  
8.	5,FixedUpdate:每帧执行一次,操作物理世界的东西(模型的移动旋转)每帧之间的时间间隔相同  (少点)  
9.	6.update():每帧执行一次,监听鼠标,键盘事件(每帧之间的时间间隔不相同)(系统决定时间间隔)(多)  
10.	7,lateUpdate();等Update结束执行此方法,常用来做相机跟随   (多)  
11.	8.OnGUI():主要用来做ui控件的展示,每帧执行一次   (次数最多)  
12.	注意:update执行一次.OnGui可能执行很多次  
13.	9,OnDisable();如果脚本不可用,执行此方法;   (前边的脚本不可用执行此方法)  
14.	如果(设置)脚本可用回到OnEnable函数中(多次)  
15.	10,OnDestroy():物体销毁执行此方法,常用来删除事件  删除通知  
16.	invoke:多久之后执行一次此方法(方法名,时间)  
17.	invokeRepeating :多长Time之后执行此方法,重复执行(方法名字,时间,时间)  
18.	Translate :移动物体(vec3.forward)  
19.	rotate:旋转物体  
20.	Destroy:销毁游戏对象  
21.	Instantiate:用来动态创建物体;参数(根据谁实例化,vec3,rotation)  
22.	事件处理 Touch Input  
23.	touch :处理触摸事件(必须真机调试)  
24.	input :键盘,鼠标,按钮,点击事件  
25.	获取组件 :getComponent<T> ()  
26.	T 组件名称  
27.	getComponent 获取物体的组件  
28.	对象可以为脚本(注意)  
29.	对象 对象的变量=getComponent<对象>();  
30.	这样就可以在一个类中调用另外一个类的方法 字段等  
31.	在子物体找组件  
32.	在父物体的脚本上,getcomponentinchildren<T>  获取 colldier 等组件   在多层级下的子物体也可以获取到  
33.	在父物体上找组件getcomponentinParent<T>  
34.	同一个物体上脚本的执行顺序:栈(自下往上)  
35.	自定义脚本的执行顺序 edit  下的最后一个,数值谁小先执行谁  
36.	同一个物体上脚本的执行顺序:  
37.	点击edit ->Projecting ->scriptsOrder ->进行设置  (小的先执行)  
38.	mainTextureOffset 主纹理偏移量  
39.	!!!这里注意  材质偏移只有(x,y)两个参数 分别代表材质在横向和纵向的偏移!!!  
40.	访问其他游戏对象  
41.	添加public gameobjecj  声明后添加  
42.	GameObject.Find(string Name)用一个gameobject 变量接受它  
43.	变量.getcomponent<>  获取其组件  操作其属性  
44.	获取游戏对象:(根据组件找物体)根据物体找组件  
45.	GameObject.Find(string name )          可以以路径的方式查找(父物体/子物体/子物体)(物体名称相同时的查找)  
46.	GameObject.FindGameObjectwITHTag<>();  
47.	GameObject.Find.FindObjectOfType<T>();找到含有T组件的物体  
48.	GameObject.Find(string name )          可以以路径的方式查找(父物体/子物体/子物体)(物体名称相同时的查找)   子物体名字相同时,从最下边的子物体向上查找  
49.	mvc  模式  m  model 模型 v  view视野 c control 控制器  
50.	mvc 就是让模型与视图分离,加上一个控制器,  
51.	这个控制器也就是一个中间的触发者,触发者通过从模型获取的数据,对ui进行改变  
52.	或者,ui改变通知触发者,让模型的数据发生改变  
53.	最大的特点就在于  不是直接操作模型与视图  通过中间的小三,让两者产生一定关系,一定改变  
54.	mvc  模式  m  model 模型 v  view视野 c control 控制器  
55.	摆放模型  
56.	模型以及其数据的控制获取  
57.	第一个类,碰撞的类,在这个类中模型的数据,与ui的数据进行交互  
58.	第二格类,玩家的信息类,这个类不用继承自monobehavior,他只是个用于初始化信息,以及字段的类  
59.	第三个类,(设置单例)  
60.	这个类的目的是:创建单例,获取玩家的信息,在类中,初始化玩家的基本信息,创建一个类类型的变量  
61.	摆放UI  
62.	UI的获取以及控制  
63.	第四个类:(设置单例)  
64.	我的容器面板 ,这个面板放了所有的UI, 只有一个这个面板,所以可以设置为单例,  
65.	因为ui面板中含有分数标签,所以需要设置一个更新标签的方法,要更新标签,需要先获取其组件  
66.	因为ui面板中有sprite图片,所以需要设置一个方法进行更改ui的图片,同样需要先获取其组件  
67.	容器面板下还有三个sprite图片,设置数组(数组为类类型的数组)进行管理,设置一个方法,管理图片的显示  
68.	第五个类:  
69.	因为有多张sprite 所以可以设为预制体,(先获取其组件)又因为图片有两种形式,所以需要添加一个设置图片的方法  
70.	模型时:  
71.	单例类,通过类类型的变量访问数据  
72.	UI时:  
73.	通过类类型的单例对象,以及类类型变量的数组,获取多个图片  
74.	最终:  
75.	在碰撞类  使用容器(面板单例)类对象,获取(玩家单例)数据模型数据,初始化UI  
76.	在碰撞的方法中:  
77.	使用玩家单例让模型的数据发生改变  
78.	使用面板的单例让ui的数据发生改变  
79.	只有一个对象,可以用单例  
80.	
